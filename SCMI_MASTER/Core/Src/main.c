/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2022 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include "GPIOx.h"
#include "RCC.h"
#include "SYSTICK.h"
#include "NVIC.h"
#include "FPU.h"


#include "I2Cx.h"

#define DBGMCU_CR                 (*( ( volatile unsigned int * ) (0xE0042004)  ) )
//**Direcciones del DS1307
static int AdreDS1307 = 0x68;///Dirección del RTC DS1307
int AdreSec= 0x00;
int AdreMin=0x01;
// Variables para manejar los valores del RTC
//uint8_t segundos, minutos, horas, dia, fecha, mes, anio;
uint32_t i;
static uint8_t buffer[8]= {0xf} , bufferI2CTx[8];
I2C_HandlerDef *direccion;
static uint8_t *buff;
/*
uint8_t buffersym[2];
uint8_t bufferhyd[2];
uint8_t bufferfym[2];
*/
//
void CargarFecha();
void leerFecha();
void I2Cx_ResetStruct( I2C_HandlerDef * i2c ,I2C_TypeDef * i2cbase);
int main(void)
{
	//SCB->AIRCR = (0x700|(0x5FA<<16));
	//DBGMCU_CR |= 7;
	//Los prescaladores se seleccionan por n=1,2,...,8. Siendo 2^n el valor del preescalador
	SystClock_Init(2,0,64,0,1,1);//SYSCLK -> PLLP, SYSPLL -> HSI, SYSCLK -> 80MHz, preAHB1 -> divided by 2^1
	 //preAPB1 -> Not divided, preAPB2 -> not divided, APB1 = 40MHZ, APB2=40MHz.
	RCC_APB2ENR |= RCC_APB2ENR_SYSCFGEN;
	//STK_CONF(64);
	I2Cx_ResetStruct(&I2C1_Struct, I2C1_R);
	I2Cx_GPIO_Init(false, I2C1);//pull up on
	I2Cx_Init(32,1,&I2C1_Struct);//10MHz, 0 -> Standard mode; 1 -> Fast Mode
	NVIC_SetCFGR(NVIC_I2C1EV_POSITION, 3);
	//NVIC_SetCFGR(NVIC_I2C1ER_POSITION, 4);
	//I2Cx_DisableIT(&I2C1_Struct);
	I2Cx_ADDRSet(AdreDS1307-15, 1, 32, &I2C1_Struct);//Address of Device, 0 -> 7 bits addressing, 0 -> APB1_freq (Set Only in 10 bits and Master Mode)
	//I2Cx_ResetACK(&I2C1_Struct);
	//direccion=&I2C1_Struct;
	//buff=bufferI2C;
	//CargarFecha(); // Función para configurar al esclavo RTC DS1307
//	for (i = 0; i < 5000000; ++i) ;
	//buffer[0]=0x00,  buffer[1]=0x40,  buffer[2]=0x09,  buffer[3]=0x04,  buffer[4]=0x31,  buffer[5]=0x10,  buffer[6]=0x19;
	//bufferI2CTx[0]=AdreSec, bufferI2CTx[1]=0x00,  bufferI2CTx[2]=0x40,  bufferI2CTx[3]=0x09,  bufferI2CTx[4]=0x04,  bufferI2CTx[5]=0x31,  bufferI2CTx[6]=0x10,  bufferI2CTx[7]=0x19;
	I2Cx_SlaveRx_IT(1, bufferI2CTx, &I2C1_Struct);

	RCC_EnPort(GPIOC);
	GPIOx_InitIO(GPIOC, 13, 0, false);

	while(1){
/*
		if((GPIOC->IDR&GPIO_IDR_ID13)==0){
			for (i = 0; i < 10000000; ++i) ;
			buffer[0]++;
			//I2Cx_MasterTx(0x59, buffer, 1, &I2C1_Struct);
			I2Cx_MasterTx_IT(0x59, 1, buffer, &I2C1_Struct);
			I2Cx_WaitBUSYReset(&I2C1_Struct);
		}
*/
		//bufferI2CTx[0]++;
		//for (i = 0; i < 10000000; ++i) ;
	    //leerFecha();
		//I2Cx_SlaveTx(buffer, 7, &I2C1_Struct);
		//I2Cx_DisableIT(&I2C1_Struct);
		//i++;
		//buffer[0]=i;
		//I2Cx_SlaveRx(bufferI2C, 1, &I2C1_Struct);
		//I2Cx_DisableIT(&I2C1_Struct);
	}
}
//RTC Incrementa la dirección o se puede ir escribiendo por una
//primero mandando la dirección y luego el dato, lo mismo con la lectura
void CargarFecha(){
	uint8_t buff[8];
    /*
     Programar: Jueves 31 de octubre del 2019, a las 9:40:00 pm

    El mapa de memoria del DS1207 es el siguiente:
    DIRECCIÓN  FUNCIÓN    BIT7   BIT6  BIT5  BIT4  BIT3  BIT2  BIT1   BIT0
        00h    Segundos     0     0     0      0    0      0    0       0
        01h     Minutos     0     0     0      0    0      0    0       0
        02h     Horas       0     0     0      1    0      0    0       0
        03h     Día         0     0     1      1    0      0    0       1
        04h     Fecha       0     0     0      0    0      1    0       0
        05h     Mes         0     0     0      1    0      0    0       0
        06h     Año         0     0     0      1    1      0    0       1
        07h     Control     0     0     0      0    0      0    1       1
     08h-3Fh    RAM 56x8
     */
    //Por lo tanto

	buff[0]=AdreSec, buff[1]=0x00,  buff[2]=0x40,  buff[3]=0x09,  buff[4]=0x04,  buff[5]=0x31,  buff[6]=0x10,  buff[7]=0x19;
	//bufferI2C[0]=AdreSec, bufferI2C[1]=0x00,  bufferI2C[2]=0x40,  bufferI2C[3]=0x09,  bufferI2C[4]=0x04,  bufferI2C[5]=0x31,  bufferI2C[6]=0x10,  bufferI2C[7]=0x19;
	//Sin interrupción
	I2Cx_MasterTx(AdreDS1307, buff, 8, &I2C1_Struct);
	I2Cx_WaitBUSYReset(&I2C1_Struct);
	//Con interrupción
	//I2Cx_MasterTx_IT(AdreDS1307, 8, bufferI2C, &I2C1_Struct);
	//for (i = 0; i < 500000; ++i) ;
}
//Se puede enviar la dirección desde la cuál comenzará y después se leen los datos
//O se puede ir leyendo una a una, transmitiendo y recibiendo
void leerFecha(){
	//Sin interrupción
	I2Cx_MasterTx(AdreDS1307, 0, 1, &I2C1_Struct);
	I2Cx_WaitBUSYReset(&I2C1_Struct);
	I2Cx_MasterRx(AdreDS1307, buffer, 7, &I2C1_Struct);
	I2Cx_WaitBUSYReset(&I2C1_Struct);
	//Con interrupción
	//I2Cx_EnableIT(&I2C1_Struct);
	//bufferI2C[0]=0;
	//I2Cx_MasterTx_IT(AdreDS1307, 1, bufferI2C, &I2C1_Struct);
	//for (i = 0; i < 5000000; ++i) ;
	//I2Cx_MasterRx_IT(AdreDS1307, 7, bufferI2CRx, &I2C1_Struct);
	//for (i = 0; i < 500000; ++i) ;
}

void I2Cx_ResetStruct( I2C_HandlerDef * i2c ,I2C_TypeDef * i2cbase){
    i2c->Registers = i2cbase;
    i2c->Parameter.ADDRDevice=0;
    i2c->Parameter.TX_RX_mode=0;
    i2c->Parameter.modeAddressing=0;
    i2c->Parameter.own_address=0;
    i2c->currentState=0;

}
