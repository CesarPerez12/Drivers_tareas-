/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2022 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include "GPIOx.h"
#include "RCC.h"
#include "SYSTICK.h"
#include "NVIC.h"
#include "UARTx.h"
uint8_t dato;
uint8_t intFlag;
void USART1_IRQHandler(void){
	intFlag = UARTx_GetInterruptFlags(&UART1_Struct);
	while(!(UARTx_SolveCurrentErrors(&UART1_Struct,UARTx_GetCurrentErrors(&UART1_Struct)))){
		UARTx_SolveCurrentErrors(&UART1_Struct,UARTx_GetCurrentErrors(&UART1_Struct));
	}
	if(!((intFlag&UART_SR_RXNE)==0)){
		dato=UART1_Struct.Registers->DR;
		UART1_Struct.Registers->SR &=~UART_SR_RXNE;
	}else if(!((intFlag&UART_SR_TC)==0)){
		UART1_Struct.Registers->SR &=~UART_SR_TC;
	}else if(!((intFlag&UART_SR_TXE)==0)){
		UART1_Struct.Registers->DR = 0xFF;
		UART1_Struct.Registers->SR &=~UART_SR_TXE;
	}
}
void UART4_IRQHandler(void){
	intFlag = UARTx_GetInterruptFlags(&UART4_Struct);
	while(!(UARTx_SolveCurrentErrors(&UART4_Struct,UARTx_GetCurrentErrors(&UART4_Struct)))){
		UARTx_SolveCurrentErrors(&UART4_Struct,UARTx_GetCurrentErrors(&UART4_Struct));
	}
	if(!((intFlag&UART_SR_RXNE)==0)){
		dato=UART4_Struct.Registers->DR;
		UART4_Struct.Registers->SR &=~UART_SR_RXNE;
	}else if(!((intFlag&UART_SR_TC)==0)){
		UART4_Struct.Registers->SR &=~UART_SR_TC;
	}else if(!((intFlag&UART_SR_TXE)==0)){
		UART4_Struct.Registers->DR = 0xFF;
		UART4_Struct.Registers->SR &=~UART_SR_TXE;
	}
}

void USART2_IRQHandler(void){
	intFlag = UARTx_GetInterruptFlags(&UART2_Struct);
		while(!(UARTx_SolveCurrentErrors(&UART2_Struct,UARTx_GetCurrentErrors(&UART2_Struct)))){
			UARTx_SolveCurrentErrors(&UART2_Struct,UARTx_GetCurrentErrors(&UART2_Struct));
		}
		if(!((intFlag&UART_SR_RXNE)==0)){
			dato=UART2_Struct.Registers->DR;
			UART2_Struct.Registers->SR &=~UART_SR_RXNE;
		}else if(!((intFlag&UART_SR_TC)==0)){
			UART2_Struct.Registers->SR &=~UART_SR_TC;
		}else if(!((intFlag&UART_SR_TXE)==0)){
			UART2_Struct.Registers->DR = 0xFF;
			UART2_Struct.Registers->SR &=~UART_SR_TXE;
		}
}
void USART3_IRQHandler(void){
	intFlag = UARTx_GetInterruptFlags(&UART3_Struct);
		while(!(UARTx_SolveCurrentErrors(&UART3_Struct,UARTx_GetCurrentErrors(&UART3_Struct)))){
			UARTx_SolveCurrentErrors(&UART3_Struct,UARTx_GetCurrentErrors(&UART3_Struct));
		}
		if(!((intFlag&UART_SR_RXNE)==0)){
			dato=UART3_Struct.Registers->DR;
			UART3_Struct.Registers->SR &=~UART_SR_RXNE;
		}else if(!((intFlag&UART_SR_TC)==0)){
			UART3_Struct.Registers->SR &=~UART_SR_TC;
		}else if(!((intFlag&UART_SR_TXE)==0)){
			UART3_Struct.Registers->DR = 0xFF;
			UART3_Struct.Registers->SR &=~UART_SR_TXE;
		}
}
void USART6_IRQHandler(void){
	intFlag = UARTx_GetInterruptFlags(&UART6_Struct);
		while(!(UARTx_SolveCurrentErrors(&UART6_Struct,UARTx_GetCurrentErrors(&UART6_Struct)))){
			UARTx_SolveCurrentErrors(&UART6_Struct,UARTx_GetCurrentErrors(&UART6_Struct));
		}
		if(!((intFlag&UART_SR_RXNE)==0)){
			dato=UART6_Struct.Registers->DR;
			UART6_Struct.Registers->SR &=~UART_SR_RXNE;
		}else if(!((intFlag&UART_SR_TC)==0)){
			UART6_Struct.Registers->SR &=~UART_SR_TC;
		}else if(!((intFlag&UART_SR_TXE)==0)){
			UART6_Struct.Registers->SR &=~UART_SR_TXE;
		}
}
int main(void){
	SYS_CLK.SYSCLK = 16;
	UARTx_ResetStruct(&UART3_Struct,UART3_R);
	UARTx_GPIO_Init(&UART3_Struct);
	UARTx_Init(9600,0x00,0x01,0x02,true,true,&UART3_Struct); //9600 baudrate, sobremuestreo por 8, 8-b de datos, even parity, transmisor y receptor habilitados
	UARTx_InterruptEN(&UART3_Struct,true,false,false,0);
	//UARTx_InterruptEN(&UART3_Struct,false,false,true,1);
	//UARTx_HalfDuplexSingleWire(&UART3_Struct);
	while(1){
		//dato=UARTx_receiveData(&UART3_Struct);
	}
	return 0;
}
